% Tic-tac-toe, using nats
% TODO: test implementation
% Comments:
% different options for win conditions...
% either general as currently.
% or specific reference to Zero.
% or at least for diagonals... since we already have two cases for these.


% Types of "objects"
player : type.

% Natural numbers
nat : type.
z : nat.
s nat : nat.

% Predicates
turn player : pred.
token player : pred.
win player : pred.
draw : pred.
occupied player nat nat : pred.
free nat nat : pred. % Free X Y
full : pred.
not_full_yet : pred.
restore nat nat : pred.
opp player player : bwd.

% Stages, main game
stage play = {
play    
    : turn A * free X Y * opp A B
    -o occupied A X Y * token B.
}
#interactive play.

go/win 
    : qui * stage play -o stage win.

stage win = {
win/row % consume the token so it doesn't go/play.
    : token B
    * occupied A X Y            % some square
    * occupied A (s X) Y        % square to the right
    * occupied A (s (s X)) Y    % another square to the right
    -o win A.
win/column
    : token B
    * occupied A X Y            % some square
    * occupied A X (s Y)        % square above
    * occupied A X (s (s Y))    % another square above
    -o win A.
win/diagonal/up
    : token B
    * occupied A X Y
    * occupied A (s X) (s Y)
    * occupied A (s (s X)) (s (s Y))
    -o win A.
win/diagonal/down
    : token B
    * occupied A X (s (s Y))
    * occupied A (s X) (s Y)
    * occupied A (s (s X)) Y
    -o win A.
check/draw
    : not_full_yet
    * free X Y
    -o restore X Y.
}

go/play
    : qui * stage win * token A * opp A B
    * restore X Y
    -o stage play * turn A * free X Y * not_full_yet.

go/draw
    : qui * stage win    
    * not_full_yet
    -o full * stage draw.

stage draw = {
draw 
    : full -o draw.
}
    

% "Objects" / terms
alice : player.
bob : player.
opp alice bob.
opp bob alice.


% Init board to free
context all_free = {        % x,y
free z z,                   % 0,0
free z (s z),               % 0,1
free z (s (s z)),           % 0,2
free (s z) z,               % 1,0
free (s z) (s z),           % 1,1
free (s z) (s (s z)),       % 1,2
free (s (s z)) z,           % 2,0
free (s (s z)) (s z),       % 2,1
free (s (s z)) (s (s z))    % 2,2
}

% Initial context
context init =
{turn alice}


#trace _ play {init, all_free, not_full_yet}.








% alternative diagonal rules

%win/diagonal/up
%    : token B
%    * occupied A z z
%    * occupied A (s z) (s z)
%    * occupied A (s (s z)) (s (s z))
%    -o win A.
%win/diagonal/down
%    : token B
%    * occupied A z (s (s z))
%    * occupied A (s z) (s z)
%    * occupied A (s (s z)) z
%    -o win A.